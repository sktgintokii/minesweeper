{"version":3,"sources":["components/MineSweeperGrid/index.js","components/MineSweeperBoard/index.js","components/Button/index.js","components/Select/index.js","classes/MineSweeperGrid.js","classes/MineSweeperBoard.js","classes/MineSweeper.js","hooks/useMineSweeper.js","App/index.js","serviceWorker.js","index.js"],"names":["MineSweeperGridWrapper","styled","div","dimension","revealed","MineSweeperGrid","size","marked","markType","hasBomb","bombCount","onClick","onRightClick","props","handleRightClick","useCallback","event","preventDefault","useMemo","getDimension","onContextMenu","defaultProps","MineSweeperBoardWrapper","attrs","board","gridColumn","length","gridRow","rowIndex","columnIndex","style","MineSweeperBoard","map","columns","grid","key","Button","Select","flag","question","none","this","getNextMarkType","gridState","getNextMarked","rowCount","columnCount","bombsState","initBombsState","generateState","initState","boardState","atRow","atColumn","getGridStateAt","getBoardSizes","traversedBoardPositions","autoRevealPositions","nextAutoRevealPositions","traversedAt","rowAt","columnAt","find","positionRowIndex","positionColumnIndex","canAutoReveal","concat","getSurroundingDirectionsAt","filter","push","getAutoRevealPositions","updateGridStateAt","reveal","mark","some","canReveal","bombPositionIndices","Set","Array","fill","value","index","Math","random","sort","a","b","slice","hasBombAt","has","reduce","mapper","isInbound","state","identifier","MineSweeper","level","hasEnded","result","initBoardState","boardConfigs","gameState","canRevealAt","hasEndedIfReviewAt","results","lost","win","undefined","revealAt","markAt","hasUnrevealedGrids","expert","intermediate","beginner","reducer","action","type","initGameState","useMineSweeper","initialState","useReducer","dispatch","restart","AppWrapper","AppHeader","header","AppToolbar","App","className","defaultValue","onChange","Option","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.588ffec4.chunk.js","sourcesContent":["import React, { useCallback, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport styled from 'styled-components';\n\nconst getDimension = size => {\n  if (size === 'small') return '1rem';\n  else if (size === 'medium') return '2rem';\n  else if (size === 'large') return '3rem';\n};\n\nconst MineSweeperGridWrapper = styled.div`\n  cursor: pointer;\n  user-select: none;\n  display: block;\n  width: ${({ dimension }) => dimension};\n  height: ${({ dimension }) => dimension};\n  background-color: ${({ revealed }) => {\n    if (revealed) return 'gray';\n    return 'white';\n  }};\n  color: black;\n  border: 1px solid black;\n\n  &:hover {\n    background-color: gray;\n  }\n`;\n\nconst MineSweeperGrid = ({\n  size,\n  revealed,\n  marked,\n  markType,\n  hasBomb,\n  bombCount = 0,\n  onClick,\n  onRightClick,\n  ...props\n}) => {\n  const handleRightClick = useCallback(\n    event => {\n      event.preventDefault();\n      onRightClick(event);\n    },\n    [onRightClick],\n  );\n  const dimension = useMemo(() => getDimension(size), [size]);\n\n  return (\n    <MineSweeperGridWrapper\n      revealed={revealed}\n      dimension={dimension}\n      onClick={onClick}\n      onContextMenu={handleRightClick}\n      {...props}\n    >\n      {revealed && !hasBomb && <>{bombCount > 0 ? bombCount : ''}</>}\n      {revealed && hasBomb && <>üí£</>}\n      {!revealed && !marked && <></>}\n      {!revealed && marked && <>{markType === 'flag' ? 'üö©' : '‚ùì'}</>}\n    </MineSweeperGridWrapper>\n  );\n};\n\nMineSweeperGrid.propTypes = {\n  revealed: PropTypes.bool.isRequired,\n  marked: PropTypes.bool.isRequired,\n  markType: PropTypes.oneOf(['flag', 'question', 'none']),\n  hasBomb: PropTypes.bool.isRequired,\n  bombCount: PropTypes.number,\n  onClick: PropTypes.func,\n  onRightClick: PropTypes.func,\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n};\n\nMineSweeperGrid.defaultProps = {\n  size: 'medium',\n};\n\nexport default MineSweeperGrid;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styled from 'styled-components';\n\nimport MineSweeperGrid from '../MineSweeperGrid';\n\nconst MineSweeperBoardWrapper = styled.div.attrs(({ board }) => ({\n  gridColumn: board[0].length,\n  gridRow: board[0].length,\n}))`\n  display: grid;\n  grid-column: ${({ board }) => board[0].length};\n  grid-row: ${({ board }) => board.length};\n`;\n\nconst MineSweeperGridWrapper = styled.div.attrs(\n  ({ rowIndex, columnIndex }) => ({\n    style: {\n      gridRow: `${rowIndex + 1} / span 1`,\n      gridColumn: `${columnIndex + 1} / span 1`,\n    },\n  }),\n)``;\n\nconst MineSweeperBoard = ({ board, onClick, onRightClick, ...props }) => {\n  return (\n    <MineSweeperBoardWrapper board={board} {...props}>\n      {board.map((columns, rowIndex) =>\n        columns.map((grid, columnIndex) => {\n          return (\n            <MineSweeperGridWrapper\n              key={`mine-sweeper-grid-${rowIndex}-${columnIndex}`}\n              rowIndex={rowIndex}\n              columnIndex={columnIndex}\n            >\n              <MineSweeperGrid\n                onClick={() =>\n                  onClick({\n                    ...grid,\n                    rowIndex,\n                    columnIndex,\n                  })\n                }\n                onRightClick={() =>\n                  onRightClick({\n                    ...grid,\n                    rowIndex,\n                    columnIndex,\n                  })\n                }\n                {...grid}\n              />\n            </MineSweeperGridWrapper>\n          );\n        }),\n      )}\n    </MineSweeperBoardWrapper>\n  );\n};\n\nMineSweeperBoard.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  onRightClick: PropTypes.func,\n  board: PropTypes.arrayOf(\n    PropTypes.arrayOf(\n      PropTypes.shape({\n        revealed: PropTypes.bool.isRequired,\n        marked: PropTypes.bool.isRequired,\n        markType: PropTypes.oneOf(['flag', 'question', 'none']),\n        hasBomb: PropTypes.bool.isRequired,\n        bombCount: PropTypes.number.isRequired,\n      }),\n    ),\n  ).isRequired,\n};\n\nexport default MineSweeperBoard;\n","import { Button } from 'antd';\nimport 'antd/dist/antd.css';\n\nexport default Button;\n","import { Select } from 'antd';\nimport 'antd/dist/antd.css';\n\nexport default Select;\n","class MineSweeperGrid {\n  static initState({\n    revealed = false,\n    marked = false,\n    markType = 'none',\n    hasBomb = false,\n    bombCount = 0,\n  } = {}) {\n    return {\n      revealed,\n      marked,\n      markType,\n      hasBomb,\n      bombCount,\n    };\n  }\n\n  static getNextMarkType(markType) {\n    return {\n      flag: 'question',\n      question: 'none',\n      none: 'flag',\n    }[markType];\n  }\n\n  static getNextMarked(markType) {\n    return this.getNextMarkType(markType) !== 'none';\n  }\n\n  static reveal(gridState) {\n    return { ...gridState, revealed: true, flag: 'none', marked: false };\n  }\n\n  static mark(gridState) {\n    return {\n      ...gridState,\n      marked: this.getNextMarked(gridState.markType),\n      markType: this.getNextMarkType(gridState.markType),\n    };\n  }\n\n  static hasBomb(gridState) {\n    return gridState.hasBomb;\n  }\n\n  static canReveal(gridState) {\n    return !gridState.revealed;\n  }\n\n  static canAutoReveal(gridState) {\n    return (\n      !gridState.revealed && !gridState.marked && gridState.bombCount === 0\n    );\n  }\n}\n\nexport default MineSweeperGrid;\n","import MineSweeperGrid from './MineSweeperGrid';\n\nclass MineSweeperBoard {\n  static initBoardState({ rowCount = 0, columnCount = 0, bombCount = 0 } = {}) {\n    const bombsState = this.initBombsState(rowCount, columnCount, bombCount);\n\n    return this.generateState(\n      rowCount,\n      columnCount,\n      (rowIndex, columnIndex) => {\n        const { hasBomb, bombCount } = bombsState[rowIndex][columnIndex];\n        return MineSweeperGrid.initState({\n          revealed: false,\n          marked: false,\n          markType: 'none',\n          hasBomb,\n          bombCount,\n        });\n      },\n    );\n  }\n\n  static updateGridStateAt = (\n    state,\n    atRow,\n    atColumn,\n    mapper = gridState => gridState,\n    identifier = (rowIndex, columnIndex) =>\n      rowIndex === atRow && columnIndex === atColumn,\n  ) =>\n    state.map((columns, rowIndex) =>\n      columns.map((gridState, columnIndex) => {\n        if (identifier(rowIndex, columnIndex)) {\n          return mapper(gridState, rowIndex, columnIndex);\n        }\n        return gridState;\n      }),\n    );\n\n  static getAutoRevealPositions(boardState, atRow, atColumn) {\n    const gridState = this.getGridStateAt(boardState, atRow, atColumn);\n\n    const { rowCount, columnCount } = this.getBoardSizes(boardState);\n    let traversedBoardPositions = [];\n    let autoRevealPositions = [[atRow, atColumn]];\n    let nextAutoRevealPositions = [];\n\n    const traversedAt = (rowAt, columnAt) =>\n      traversedBoardPositions.find(\n        ([positionRowIndex, positionColumnIndex]) =>\n          positionRowIndex === rowAt && positionColumnIndex === columnAt,\n      );\n    do {\n      nextAutoRevealPositions = [];\n      for (const [atRow, atColumn] of autoRevealPositions) {\n        const traversed = traversedAt(atRow, atColumn);\n        if (traversed) continue;\n\n        const gridState = this.getGridStateAt(boardState, atRow, atColumn);\n        nextAutoRevealPositions = MineSweeperGrid.canAutoReveal(gridState)\n          ? nextAutoRevealPositions.concat(\n              this.getSurroundingDirectionsAt(\n                atRow,\n                atColumn,\n                rowCount,\n                columnCount,\n              ).filter(([rowIndex, columnIndex]) => {\n                const gridState = this.getGridStateAt(\n                  boardState,\n                  rowIndex,\n                  columnIndex,\n                );\n                const traversed = traversedAt(rowIndex, columnIndex);\n                return !traversed && !MineSweeperGrid.hasBomb(gridState);\n              }),\n            )\n          : nextAutoRevealPositions;\n\n        traversedBoardPositions.push([atRow, atColumn]);\n      }\n\n      autoRevealPositions = nextAutoRevealPositions;\n    } while (nextAutoRevealPositions.length);\n\n    return traversedBoardPositions;\n  }\n\n  static revealAt(boardState, atRow, atColumn) {\n    const autoRevealPositions = this.getAutoRevealPositions(\n      boardState,\n      atRow,\n      atColumn,\n    );\n\n    const newBoardState = this.updateGridStateAt(\n      boardState,\n      atRow,\n      atColumn,\n      gridState => MineSweeperGrid.reveal(gridState),\n      (rowIndex, columnIndex) => {\n        return (\n          (rowIndex === atRow && columnIndex === atColumn) ||\n          !!autoRevealPositions.find(\n            ([positionRowIndex, positionColumnIndex]) =>\n              positionRowIndex === rowIndex &&\n              positionColumnIndex === columnIndex,\n          )\n        );\n      },\n    );\n\n    return newBoardState;\n  }\n\n  static markAt(boardState, atRow, atColumn) {\n    const newBoardState = this.updateGridStateAt(\n      boardState,\n      atRow,\n      atColumn,\n      gridState => MineSweeperGrid.mark(gridState),\n    );\n\n    return newBoardState;\n  }\n\n  static hasUnrevealedGrids(boardState) {\n    return boardState.some(columns =>\n      columns.some(gridState => MineSweeperGrid.canReveal(gridState)),\n    );\n  }\n\n  static hasBombAt(boardState, atRow, atColumn) {\n    const gridState = this.getGridStateAt(boardState, atRow, atColumn);\n    return MineSweeperGrid.hasBomb(gridState);\n  }\n\n  static getGridStateAt(boardState, atRow, atColumn) {\n    return boardState[atRow][atColumn];\n  }\n\n  static canRevealAt(boardState, atRow, atColumn) {\n    const gridState = this.getGridStateAt(boardState, atRow, atColumn);\n    return MineSweeperGrid.canReveal(gridState);\n  }\n\n  static initBombsState(rowCount, columnCount, bombCount) {\n    const bombPositionIndices = new Set(\n      Array(rowCount * columnCount)\n        .fill()\n        .map((value, index) => ({ index, value: Math.random() }))\n        .sort((a, b) => b.value - a.value)\n        .slice(0, bombCount)\n        .map(({ index }) => index),\n    );\n\n    const hasBombAt = (atRow, atColumn) =>\n      bombPositionIndices.has(atRow * columnCount + atColumn);\n    const getSurroundingBombCountAt = (atRow, atColumn) =>\n      this.getSurroundingDirectionsAt(\n        atRow,\n        atColumn,\n        rowCount,\n        columnCount,\n      ).reduce((bombCount, [rowIndex, columnIndex]) => {\n        return bombCount + (hasBombAt(rowIndex, columnIndex) ? 1 : 0);\n      }, 0);\n\n    return this.generateState(\n      rowCount,\n      columnCount,\n      (rowIndex, columnIndex) => {\n        return {\n          hasBomb: hasBombAt(rowIndex, columnIndex),\n          bombCount: getSurroundingBombCountAt(rowIndex, columnIndex),\n        };\n      },\n    );\n  }\n\n  static generateState(rowCount, columnCount, mapper) {\n    return Array(rowCount)\n      .fill()\n      .map((columns, rowIndex) =>\n        Array(columnCount)\n          .fill()\n          .map((grid, columnIndex) => mapper(rowIndex, columnIndex)),\n      );\n  }\n\n  static isInbound(atRow, atColumn, rowCount, columnCount) {\n    return (\n      atRow >= 0 &&\n      atRow < rowCount &&\n      (atColumn >= 0 && atColumn < columnCount)\n    );\n  }\n\n  static getSurroundingDirectionsAt(atRow, atColumn, rowCount, columnCount) {\n    return [\n      [atRow - 1, atColumn], // top\n      [atRow - 1, atColumn + 1], // top right\n      [atRow, atColumn + 1], // right\n      [atRow + 1, atColumn + 1], // bottom right\n      [atRow + 1, atColumn], // bottom\n      [atRow + 1, atColumn - 1], // bottom left\n      [atRow, atColumn - 1], // left\n      [atRow - 1, atColumn - 1], // top left\n    ].filter(([rowIndex, columnIndex]) =>\n      this.isInbound(rowIndex, columnIndex, rowCount, columnCount),\n    );\n  }\n\n  static getBoardSizes(boardState) {\n    return { rowCount: boardState.length, columnCount: boardState[0].length };\n  }\n}\n\nexport default MineSweeperBoard;\n","import MineSweeperBoard from './MineSweeperBoard';\n\nclass MineSweeper {\n  static boardConfigs = {\n    expert: {\n      rowCount: 16,\n      columnCount: 30,\n      bombCount: 99,\n    },\n    intermediate: {\n      rowCount: 16,\n      columnCount: 16,\n      bombCount: 40,\n    },\n    beginner: {\n      rowCount: 10,\n      columnCount: 10,\n      bombCount: 10,\n    },\n  };\n  static results = {\n    win: 'win',\n    lost: 'lost',\n  };\n\n  static initGameState({ level = 'expert', hasEnded = false, result }) {\n    return {\n      level,\n      hasEnded,\n      result,\n      boardState: MineSweeperBoard.initBoardState(this.boardConfigs[level]),\n    };\n  }\n\n  static revealAt(gameState, atRow, atColumn) {\n    const { boardState } = gameState;\n    const canRevealAt = MineSweeperBoard.canRevealAt(\n      boardState,\n      atRow,\n      atColumn,\n    );\n    const hasBombAt = MineSweeperBoard.canRevealAt(boardState, atRow, atColumn);\n    const hasEndedIfReviewAt = this.hasEndedIfReviewAt(\n      gameState,\n      atRow,\n      atColumn,\n    );\n\n    if (!canRevealAt || gameState.hasEnded) {\n      return gameState;\n    }\n\n    return {\n      ...gameState,\n      hasEnded: hasEndedIfReviewAt,\n      result: hasEndedIfReviewAt\n        ? hasBombAt\n          ? this.results.lost\n          : this.results.win\n        : undefined,\n      boardState: MineSweeperBoard.revealAt(boardState, atRow, atColumn),\n    };\n  }\n\n  static markAt(gameState, atRow, atColumn) {\n    if (gameState.hasEnded) {\n      return gameState;\n    }\n\n    return {\n      ...gameState,\n      boardState: MineSweeperBoard.markAt(\n        gameState.boardState,\n        atRow,\n        atColumn,\n      ),\n    };\n  }\n\n  static hasEndedIfReviewAt(gameState, atRow, atColumn) {\n    const hasBombAt = MineSweeperBoard.hasBombAt(\n      gameState.boardState,\n      atRow,\n      atColumn,\n    );\n    const hasUnrevealedGrids = MineSweeperBoard.hasUnrevealedGrids(\n      gameState.boardState,\n    );\n\n    return hasBombAt || !hasUnrevealedGrids;\n  }\n}\n\nexport default MineSweeper;\n","import { useReducer } from 'react';\nimport { MineSweeper } from '../classes';\n\nconst reducer = (gameState, action) => {\n  switch (action.type) {\n    case 'revealAt':\n      return MineSweeper.revealAt(gameState, action.atRow, action.atColumn);\n    case 'markAt':\n      return MineSweeper.markAt(gameState, action.atRow, action.atColumn);\n    case 'restart':\n      return MineSweeper.initGameState({ level: action.level });\n    default:\n  }\n};\n\nconst useMineSweeper = level => {\n  const initialState = MineSweeper.initGameState({ level });\n  const [gameState, dispatch] = useReducer(reducer, initialState);\n\n  const revealAt = (atRow, atColumn) => {\n    dispatch({ type: 'revealAt', atRow, atColumn });\n  };\n  const markAt = (atRow, atColumn) => {\n    dispatch({ type: 'markAt', atRow, atColumn });\n  };\n  const restart = level => {\n    dispatch({ type: 'restart', level });\n  };\n  return [gameState, { revealAt, markAt, restart }];\n};\n\nexport default useMineSweeper;\n","import React from 'react';\nimport styled from 'styled-components';\nimport MineSweeperBoard from '../components/MineSweeperBoard';\nimport { Button, Select } from '../components';\nimport useMineSweeper from '../hooks/useMineSweeper';\n\nconst AppWrapper = styled.div`\n  text-align: center;\n  min-height: 100vh;\n  background-color: #282c34;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: calc(10px + 2vmin);\n  overflow: auto;\n`;\n\nconst AppHeader = styled.header`\n  font-size: calc(16px + 2vmin);\n  margin-bottom: 1rem;\n`;\n\nconst AppToolbar = styled.div`\n  > * {\n    margin: 0 1rem;\n    min-width: 10rem;\n  }\n`;\n\nconst App = () => {\n  const [gameState, { revealAt, markAt, restart }] = useMineSweeper();\n\n  return (\n    <AppWrapper className=\"App\">\n      <AppHeader className=\"App-header\">\n        <div>Minesweeper</div>\n        <AppToolbar>\n          <Select defaultValue={gameState.level} onChange={restart}>\n            <Select.Option value=\"expert\">Expert</Select.Option>\n            <Select.Option value=\"intermediate\">Intermediate</Select.Option>\n            <Select.Option value=\"beginner\">Beginner</Select.Option>\n          </Select>\n          <Button onClick={() => restart(gameState.level)}>\n            {gameState.result || 'Restart'}\n          </Button>\n        </AppToolbar>\n      </AppHeader>\n      <MineSweeperBoard\n        board={gameState.boardState}\n        onClick={({ rowIndex, columnIndex }) => revealAt(rowIndex, columnIndex)}\n        onRightClick={({ rowIndex, columnIndex }) =>\n          markAt(rowIndex, columnIndex)\n        }\n      />\n    </AppWrapper>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}